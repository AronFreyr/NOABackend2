# Why cookie auth?

Cookie auth is an established secure and simple authentication form. Django has built in support for session cookies and other auth forms rely on third party libraries of varying quality.

For example if you use JWT you will need to implement a refresh mechanism and for force logout you will need to implement a blacklist. The strengths of JWT when we have no actual information to attach to it are dubious at best and the technical complexity and backwardness of having a database call to a blacklist instead of to see if a session exists makes JWT seem unattractive for a Django monolith. JWT also moves the job of securing auth from backend to frontend, leading to potential security vulnerabilities if it is not done correctly in frontend.

One issue with using cookie-based session auth is that the backend is now vulnerable to CSRF since the cookie is sent with every request to the domain no matter what origin the request has. This means we need to ensure CSRF protection and makes it extra important to have CORS headers configured correctly if the frontend is on a different domain. 

One big issue with DRFs CSRF protection is that **by default it is not enabled for non-authenticated requests**. This needs to be kept in mind if one is building e.g. an IP-whitelisted form or something else where you can have a CSRF vulnerability while not logged in. CSRF protection can easily be re-enabled by adding `@method_decorator(csrf_protect, name="dispatch")` to the CBV. This is required for login and registration views to avoid [login CSRF](https://en.wikipedia.org/wiki/Cross-site_request_forgery#Forging_login_requests).

<!-- TODO: Document potential security risks of shared subdomains -->

# How does frontend cookie auth?

This JS example using Fetch is AI-generated by a backend-developer.

```js
const baseUrl = "http://localhost:8000/"  // Enter your real base url
const csrfUrl = baseUrl + "users/csrf/"
const loginUrl = baseUrl+ "users/login/"
const userMeUrl = baseUrl + "users/me/"

const data = {
    email: "test@example.com",  // Enter real email
    password: "supersecretpassword"  // Enter real password
}

const csrfOptions = {
  method: 'GET',
  credentials: 'include',
};

const loginOptions = {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
    'Accept': 'application/json',
  },
  body: JSON.stringify(data),
  credentials: 'include'
};


const res = fetch(csrfUrl, csrfOptions)
  .then(response => response.json())
  .then(data => {
    const csrfToken = data['csrf_token'];
    loginOptions.headers['X-CSRFToken'] = csrfToken;
    return fetch(loginUrl, loginOptions);
  })
  .then(response => response.text())
  .then(text => console.log('Login response:', text))
  .then(() => fetch(userMeUrl, {credentials: 'include'}))
  .then(response => response.json())
  .then(data => console.log('User:', data))
  .catch(error => console.error('Error:', error));
```


# Is the /users/csrf/ JSON endpoint really secure?

Short answer: yes.

There is a lot of blanket statements on the internet saying "Do not expose CSRF token via API". Always offered without further explanation. After hours of research, no attack vector has been found describing how this would be an actual vulnerability.

Why is this secure? Let's narrow it down:

* The only attack vector for CSRF attacks is a browser where the user is already logged in
* AJAX via browsers respect CORS headers
* Non-AJAX requests e.g. form GET / POST are blind, aka there is no way for the attacker to read the data of the response as it redirects to the site it POSTs to.

These two facts eliminates the attack vectors:

* AJAX POST - this will fail since the pre-flight CORS header response will block the request
* Form POST - this will not be doable since it requires the user to include the CSRF token from `GET /users/csrf/` which will not be readable due to CORS headers blocking the request in pre-flight
* Any non-browser request will not be vulnerable since the user is not logged in so there is no attack vector for the CSRF attack (except login CSRF, which is a smaller and more novel attack vector)

Some interesting links:

* [Tutorial to implement with /csrf/ endpoint, explaining why it's not a risk briefly](https://fractalideas.com/blog/making-react-and-django-play-well-together-single-page-app-model/#fn:7)
* [Reddit comment explaining why CORS blocks this attack vector](https://www.reddit.com/r/django/comments/zm5dbn/csrf_with_drf_and_spa/j0a4zox/)
* [Security Stack Exchange thread suggesting it](https://security.stackexchange.com/questions/182889/csrf-token-for-api-serving-application)
* [Github issue debating a blanket statement that this is bad](https://github.com/pillarjs/understanding-csrf/issues/6)

Note: If frontend and backend is on the same subdomain, there is no need to expose the CSRF token via API and the default Django approach using cookies only can be used. However, this would greatly complicate for local development as the backend then would need to be on the same domain for local dev as well for frontend to be able to read the cookie. One approach could be to have different implementations for local dev and dev / prod environments.

# XSS

Do not miss the forest for the trees. Any XSS vulnerability will defeat all CSRF mitigation. Sadly XSS vulnerabilities are still very easy to write both in Django Admin and in JS frontends. Remember to keep the [OWASP top 10 cheat sheet](https://cheatsheetseries.owasp.org/IndexTopTen.html) in mind.
